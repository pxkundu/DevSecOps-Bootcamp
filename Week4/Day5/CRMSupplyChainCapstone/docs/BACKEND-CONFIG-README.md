This Document specifically tailored for the local setup of the **Phase 2: Backend - Microservices Development** deliverables in the **CRM-Integrated Global Supply Chain System** capstone project. 

This README focuses on guiding a developer through setting up and running the four backend services (`crm-api`, `inventory-service`, `logistics-service`, `order-service`) and the PostgreSQL database (`crm_supply_db`) locally, using the deliverables generated by `generate-phase2-deliverables-full.sh`. 

It assumes a local development environment and provides step-by-step instructions, prerequisites, and troubleshooting tips to ensure a smooth setup, reflecting real-world configuration practices.

---
# CONFIG-README: Local Setup for Phase 2 Backend Components

This guide outlines how to set up and run the backend components from **Phase 2: Backend - Microservices Development** of the CRM-Integrated Global Supply Chain System locally. It covers the four microservices (`crm-api`, `inventory-service`, `logistics-service`, `order-service`) and the PostgreSQL database (`crm_supply_db`) on your machine, using Docker and a local PostgreSQL instance. This setup is designed for development and testing purposes, with no AWS dependencies yet (those come in later phases).

---

## Prerequisites
Before starting, ensure you have the following installed:
- **Node.js**: Version 18.x (LTS as of 2023, compatible with `node:18-alpine`).
  - Install: `curl -fsSL https://deb.nodesource.com/setup_18.x | sudo -E bash - && sudo apt-get install -y nodejs` (Linux) or use [Node.js installer](https://nodejs.org/).
- **Docker**: Latest stable version for building and running containerized services.
  - Install: `sudo apt-get install docker.io` (Linux) or [Docker Desktop](https://www.docker.com/products/docker-desktop) (Windows/Mac).
- **PostgreSQL**: Version 14+ (16/17 by March 2025) for the database.
  - Install: `sudo apt-get install postgresql` (Linux) or [PostgreSQL installer](https://www.postgresql.org/download/).
- **Git**: For cloning or managing the project repo.
  - Install: `sudo apt-get install git`.
- **Text Editor**: e.g., VS Code, for editing files if needed.

---

## Project Structure
The relevant files for this setup are located in:
```
CRMSupplyChainCapstone/
├── services/
│   ├── crm-api/               # CRM API service
│   │   ├── Dockerfile
│   │   ├── app.js
│   │   └── package.json
│   ├── inventory-service/     # Supply chain inventory service
│   │   ├── Dockerfile
│   │   ├── app.js
│   │   └── package.json
│   ├── logistics-service/     # Supply chain logistics service
│   │   ├── Dockerfile
│   │   ├── app.js
│   │   └── package.json
│   ├── order-service/         # Supply chain order service
│   │   ├── Dockerfile
│   │   ├── app.js
│   │   └── package.json
├── docs/
│   └── db-schema.sql          # PostgreSQL schema for crm_supply_db
```

---

## Step-by-Step Local Setup

### 1. Clone or Generate the Project
- If you haven’t already, generate the Phase 2 deliverables:
  ```bash
  chmod +x generate-phase2-deliverables-full.sh
  ./generate-phase2-deliverables-full.sh
  ```
- Navigate to the project root:
  ```bash
  cd CRMSupplyChainCapstone
  ```

### 2. Set Up PostgreSQL Database
- **Start PostgreSQL**:
  - On Linux: `sudo systemctl start postgresql`
  - On Mac/Windows: Ensure PostgreSQL service is running (via installer or `pg_ctl`).
- **Create User and Database**:
  ```bash
  sudo -u postgres psql
  ```
  Inside `psql`:
  ```sql
  CREATE USER admin WITH PASSWORD 'securepassword';
  CREATE DATABASE crm_supply_db OWNER admin;
  \q
  ```
- **Apply Schema**:
  ```bash
  psql -U admin -d crm_supply_db -f docs/db-schema.sql
  ```
  - Verify: Connect with `psql -U admin -d crm_supply_db` and run `\dt` to see tables (`customers`, `inventory`, `orders`).

### 3. Configure Environment Variables
- Each service uses environment variables for DB and service connections. For local setup, we’ll override defaults manually when running Docker containers. Create a `.env` file in each service directory if preferred (optional):
  ```
  DB_USER=admin
  DB_HOST=localhost
  DB_NAME=crm_supply_db
  DB_PASSWORD=securepassword
  DB_PORT=5432
  ```
- For simplicity, we’ll pass these via Docker run commands below.

### 4. Build and Run Docker Containers
Run each service in its own terminal or background process. Use Docker to build and start them locally.

#### a. `crm-api`
- Build:
  ```bash
  cd services/crm-api
  docker build -t crm-api:latest .
  ```
- Run:
  ```bash
  docker run -d -p 3000:3000 --name crm-api \
    -e DB_HOST=host.docker.internal \
    -e DB_USER=admin \
    -e DB_PASSWORD=securepassword \
    -e DB_NAME=crm_supply_db \
    crm-api:latest
  ```
  - Note: `host.docker.internal` connects to your local machine’s PostgreSQL; use `localhost` if not on Docker Desktop (e.g., Linux).

#### b. `inventory-service`
- Build:
  ```bash
  cd ../inventory-service
  docker build -t inventory-service:latest .
  ```
- Run:
  ```bash
  docker run -d -p 4000:4000 --name inventory-service \
    -e DB_HOST=host.docker.internal \
    -e DB_USER=admin \
    -e DB_PASSWORD=securepassword \
    -e DB_NAME=crm_supply_db \
    inventory-service:latest
  ```

#### c. `logistics-service`
- Build:
  ```bash
  cd ../logistics-service
  docker build -t logistics-service:latest .
  ```
- Run:
  ```bash
  docker run -d -p 5000:5000 --name logistics-service logistics-service:latest
  ```

#### d. `order-service`
- Build:
  ```bash
  cd ../order-service
  docker build -t order-service:latest .
  ```
- Run:
  ```bash
  docker run -d -p 6000:6000 --name order-service \
    -e DB_HOST=host.docker.internal \
    -e DB_USER=admin \
    -e DB_PASSWORD=securepassword \
    -e DB_NAME=crm_supply_db \
    order-service:latest
  ```

### 5. Verify Services
- Check logs to ensure services are running:
  ```bash
  docker logs crm-api
  docker logs inventory-service
  docker logs logistics-service
  docker logs order-service
  ```
- Expected output: “running on port XXXX” for each.

### 6. Test Endpoints
Use `curl` or a tool like Postman to test the services:
- **crm-api**:
  - Create order:
    ```bash
    curl -X POST http://localhost:3000/orders \
      -H "Content-Type: application/json" \
      -d '{"customerId": 1, "productId": "prod-001", "quantity": 5}'
    ```
  - Get order:
    ```bash
    curl http://localhost:3000/orders/1
    ```
- **inventory-service**:
  - Check stock:
    ```bash
    curl http://localhost:4000/inventory/prod-001
    ```
- **logistics-service**:
  - Create shipment (manual test):
    ```bash
    curl -X POST http://localhost:5000/shipments \
      -H "Content-Type: application/json" \
      -d '{"orderId": 1}'
    ```
- **order-service**:
  - Process order (manual test):
    ```bash
    curl -X POST http://localhost:6000/supply-orders \
      -H "Content-Type: application/json" \
      -d '{"orderId": 1, "customerId": 1, "productId": "prod-001", "quantity": 5}'
    ```

---

## Notes
- **Local Limitations**: 
  - Services assume direct `localhost` access to each other (e.g., `order-service` calls `inventory-service:4000`). For full integration, use Docker Compose or adjust hostnames (e.g., link containers) in a future step.
  - Current setup runs independently; inter-service calls may fail until networked (e.g., `http://inventory-service:4000` won’t resolve locally without a bridge network).
- **DB Connection**: Ensure PostgreSQL is accessible from Docker (e.g., `host.docker.internal` on Mac/Windows; `localhost` might need `--network host` on Linux).
- **Security**: Hardcoded `securepassword` is for local use; replace with Secrets Manager in production (Phase 5).

---

## Troubleshooting
- **Service Won’t Start**: Check `docker logs <container-name>` for errors (e.g., DB connection refused).
- **DB Connection Fails**: Verify PostgreSQL is running (`ps aux | grep postgres`) and credentials match.
- **Port Conflicts**: Stop other services on ports 3000, 4000, 5000, 6000 if needed (`sudo lsof -i :3000`).
- **Order Fails**: Ensure `inventory-service` and `logistics-service` are up before `order-service` calls them.

---

## Next Steps
- **Phase 3**: Build frontend UIs (`crm-ui`, `tracking-ui`) to interact with these services.
- **Phase 4**: Deploy to Kubernetes (EKS) with proper service discovery.
- **Enhancement**: Use Docker Compose locally for networked services:
  ```yaml
  version: '3'
  services:
    crm-api:
      build: ./services/crm-api
      ports: ["3000:3000"]
      environment:
        DB_HOST: postgres
    inventory-service:
      build: ./services/inventory-service
      ports: ["4000:4000"]
      environment:
        DB_HOST: postgres
    logistics-service:
      build: ./services/logistics-service
      ports: ["5000:5000"]
    order-service:
      build: ./services/order-service
      ports: ["6000:6000"]
      environment:
        DB_HOST: postgres
    postgres:
      image: postgres:16
      environment:
        POSTGRES_USER: admin
        POSTGRES_PASSWORD: securepassword
        POSTGRES_DB: crm_supply_db
      volumes:
        - ./docs/db-schema.sql:/docker-entrypoint-initdb.d/init.sql

This setup gets you running locally—happy coding!

---

### Explanation
- **Purpose**: Guides a developer to set up Phase 2’s backend locally, focusing on Dockerized services and PostgreSQL.
- **Steps**: Covers DB setup, Docker builds, and testing with clear commands, reflecting real-world dev workflows.
- **Config**: Uses env vars for flexibility, with notes on local limitations (e.g., service discovery).
- **Troubleshooting**: Addresses common issues (e.g., port conflicts, DB connectivity), enhancing usability.
- **Next Steps**: Suggests Docker Compose for a networked local setup, bridging to Phase 4’s Kubernetes deployment.

