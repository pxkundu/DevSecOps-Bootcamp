Let’s dive into **Week 4, Day 3: Kubernetes Fundamentals** from our 6-week DevOps bootcamp. 

Today we shift focus from Terraform (Days 1-2) to **Kubernetes**, introducing container orchestration essentials for managing the CRM Platform’s microservices (e.g., `crm-api`, `crm-ui`, `crm-analytics`) deployed in the prior implementation.

I’ll provide an extensively informative exploration, blending theoretical keyword explanations with practical, real-world use cases aligned with Fortune 100 DevOps practices. 

This builds on the AWS EKS clusters provisioned with Terraform, integrating Docker, Jenkins, and GitHub workflows from Day 2, and prepares you for Day 4’s advanced Kubernetes topics and the Week 4 capstone.

---

## Week 4, Day 3: Kubernetes Fundamentals

### Overview
Day 3 introduces **Kubernetes (K8s)**, the industry-standard container orchestration platform, focusing on its core concepts and basic operations. You’ll learn to deploy and manage the CRM microservices on the EKS clusters created in Day 2, transitioning from Docker’s single-host management to Kubernetes’ distributed, scalable architecture. This foundational knowledge is critical for production-grade DevOps, reflecting practices at companies like Google, Netflix, and Salesforce.

### Learning Objectives
- Understand Kubernetes architecture and core objects (Pods, Deployments, Services).
- Deploy containerized applications (e.g., CRM microservices) on EKS.
- Manage basic K8s operations with `kubectl`.
- Prepare for scaling and resilience in multi-region setups.

### Prerequisites
- Day 2’s Terraform setup (`CRMTerraformJenkins/terraform/` with EKS clusters).
- Docker images in ECR (`crm-api`, `crm-ui`, `crm-analytics`).
- Tools: `kubectl` (`brew install kubectl`), `aws cli`, `eksctl` (`brew install eksctl`).

### Time Allocation
- **Theory**: 1.5 hours
- **Practical**: 1.5 hours
- **Total**: 3 hours

---

### Theoretical Explanation

#### Key Concepts & Keywords
1. **Cluster**:
   - **Definition**: A set of nodes (master + workers) running Kubernetes, managed by a control plane.
   - **Components**: 
     - **Control Plane**: API Server, Scheduler, Controller Manager, etcd (key-value store).
     - **Worker Nodes**: Run Pods, managed by kubelet and kube-proxy.
   - **Why**: Provides a unified platform for container orchestration across hosts.

2. **Pod**:
   - **Definition**: The smallest deployable unit in Kubernetes, containing one or more containers (e.g., Docker).
   - **Features**: Shares network (single IP) and storage volumes; co-located on one node.
   - **Lifecycle**: Created, runs, terminates; managed by higher-level objects.
   - **Why**: Abstracts container management, enabling portability.

3. **Deployment**:
   - **Definition**: A declarative object managing a set of Pods, ensuring desired state (e.g., 3 replicas).
   - **Functions**: Rolling updates, scaling, self-healing (restarts failed Pods).
   - **Why**: Ensures application reliability and zero-downtime updates.

4. **Service**:
   - **Definition**: An abstraction providing stable networking to Pods (e.g., LoadBalancer, ClusterIP).
   - **Types**: 
     - **ClusterIP**: Internal access (default).
     - **LoadBalancer**: Exposes to external traffic (e.g., AWS ELB).
     - **NodePort**: Maps to node ports.
   - **Why**: Provides consistent access despite Pod ephemerality.

5. **Namespace**:
   - **Definition**: A virtual cluster within Kubernetes, isolating resources (e.g., `dev-us`, `prod-us`).
   - **Use**: Segregates environments or teams; default is `default`.
   - **Why**: Enhances multi-tenancy and resource management.

6. **kubectl**:
   - **Definition**: Command-line tool to interact with the Kubernetes API.
   - **Commands**: `kubectl apply`, `get`, `describe`, `delete`.
   - **Why**: Primary interface for managing K8s resources.

7. **Kubeconfig**:
   - **Definition**: Configuration file (`~/.kube/config`) authenticating `kubectl` to clusters.
   - **Setup**: Generated by `aws eks update-kubeconfig`.
   - **Why**: Enables secure cluster access.

#### Why Kubernetes Matters
- **Scalability**: Manages 1000s of containers across nodes, unlike Docker’s single-host limit.
- **Resilience**: Self-healing (restarts failed Pods) and load balancing ensure uptime.
- **Portability**: Runs on AWS, GCP, on-prem, standardizing deployments.
- **Ecosystem**: Integrates with CI/CD (Jenkins), IaC (Terraform), and monitoring (Prometheus).

#### Comparison to Alternatives
- **Docker Swarm**: Simpler but less scalable, lacks advanced features.
- **AWS ECS**: Tighter AWS integration, less portable than K8s.
- **Nomad**: Lightweight, but smaller community vs. K8s.

#### Best Practices
- Use namespaces for team/env isolation.
- Define resource limits (CPU, memory) per Pod.
- Leverage Deployments, not raw Pods, for management.
- Label resources (e.g., `app=crm-api`) for organization.

---

### Practical Use Cases & Real-World Applications

#### Practical Activity Plan
- **Objective**: Deploy CRM microservices (`crm-api`, `crm-ui`, `crm-analytics`) on EKS.
- **Setup**: Use Day 2’s `CRMTerraformJenkins` project, focusing on `dev-us` EKS cluster.
- **Tasks**:
  1. **Configure Kubeconfig**: Connect to EKS.
  2. **Create Namespace**: Isolate `dev-us`.
  3. **Define Deployments**: Launch microservices from ECR.
  4. **Expose Services**: Access via LoadBalancer.
  5. **Verify**: Check Pods and Services with `kubectl`.
- **Outcome**: Running CRM app on EKS, accessible externally.

#### Real-World Use Case 1: Salesforce CRM Deployment
- **Scenario**: Salesforce deploys its CRM on EKS for global sales teams.
- **Context**: Microservices (`crm-api`, `crm-ui`) serve millions of users, requiring scalability and uptime.
- **Theoretical Application**:
  - **Cluster**: EKS in `us-east-1` with 10 worker nodes.
  - **Pod**: Runs `crm-api` container from ECR.
  - **Deployment**: Ensures 5 `crm-api` replicas, self-heals crashes.
  - **Service**: LoadBalancer exposes `crm-ui` to sales reps.
  - **Namespace**: `prod-us` isolates production.
- **Practical Workflow**:
  - `kubectl apply -f crm-api-deployment.yaml`.
  - `kubectl get pods -n prod-us`: Verifies 5 Pods.
  - Outcome: CRM scales to 10,000 requests/sec, 99.99% uptime.
- **DevOps Impact**: 
  - Automates scaling for peak sales seasons.
  - Reduces downtime with self-healing.

#### Real-World Use Case 2: Netflix Content Delivery
- **Scenario**: Netflix orchestrates streaming microservices on Kubernetes.
- **Context**: Delivers content globally, requiring low latency and resilience.
- **Theoretical Application**:
  - **Cluster**: Multi-region K8s (AWS, GCP) with 100s of nodes.
  - **Pod**: Runs `content-stream` container.
  - **Service**: ClusterIP for internal API calls, LoadBalancer for edge servers.
  - **kubectl**: `kubectl scale deployment content-stream --replicas=50`.
- **Practical Workflow**:
  - Deploy: `kubectl apply -f content-stream.yaml`.
  - Verify: `kubectl get svc`: Checks LoadBalancer IP.
  - Outcome: Streams to 200M users with zero buffering.
- **DevOps Impact**: 
  - Scales Pods dynamically for Super Bowl traffic.
  - Simplifies multi-cloud ops.

#### Real-World Use Case 3: Your CRM Platform
- **Scenario**: Deploy Day 2’s CRM microservices to EKS.
- **Context**: Transition from Docker local to EKS `dev-us` cluster.
- **Theoretical Application**:
  - **Cluster**: Day 2’s EKS in `us-east-1`.
  - **Pod**: Runs `crm-ui` from ECR.
  - **Deployment**: 3 replicas of `crm-api`.
  - **Service**: LoadBalancer for `crm-ui`.
  - **Namespace**: `dev-us` for testing.
- **Practical Workflow**:
  - `aws eks update-kubeconfig --name dev-us-crm-us-east-1`.
  - `kubectl apply -f crm-deployment.yaml -n dev-us`.
  - Outcome: CRM UI at `<LoadBalancerIP>:80`.
- **DevOps Impact**: 
  - Prepares for Jenkins pipeline integration.
  - Tests microservices in a production-like env.

---

### Lesson Plan Details

#### Theory Session (1.5 hr)
- **Topics**:
  1. **Kubernetes Architecture (20 min)**:
     - Control plane vs. worker nodes.
     - Role of etcd, API Server, Scheduler.
  2. **Core Objects (40 min)**:
     - **Pod**: Container encapsulation.
     - **Deployment**: Desired state management.
     - **Service**: Networking abstraction.
     - **Namespace**: Resource isolation.
  3. **kubectl Basics (30 min)**:
     - Commands: `apply`, `get`, `describe`.
     - Kubeconfig setup with AWS EKS.
- **Delivery**: Slides, demo of `kubectl get nodes`.

#### Practical Session (1.5 hr)
- **Activity**: Deploy CRM microservices to EKS.
- **Steps**:
  1. **Setup (15 min)**:
     - Update kubeconfig: `aws eks update-kubeconfig --name dev-us-crm-us-east-1 --region us-east-1`.
     - Create namespace: `kubectl create namespace dev-us`.
  2. **Define Resources (45 min)**:
     - Write `crm-deployment.yaml`:
       ```yaml
       apiVersion: v1
       kind: Namespace
       metadata:
         name: dev-us
       ---
       apiVersion: apps/v1
       kind: Deployment
       metadata:
         name: crm-api
         namespace: dev-us
       spec:
         replicas: 3
         selector:
           matchLabels:
             app: crm-api
         template:
           metadata:
             labels:
               app: crm-api
           spec:
             containers:
             - name: crm-api
               image: 866934333672.dkr.ecr.us-east-1.amazonaws.com/dev-us-crm-api:latest
               ports:
               - containerPort: 3000
       ---
       apiVersion: v1
       kind: Service
       metadata:
         name: crm-api-service
         namespace: dev-us
       spec:
         selector:
           app: crm-api
         ports:
         - port: 80
           targetPort: 3000
         type: LoadBalancer
       ```
     - Repeat for `crm-ui`, `crm-analytics`.
  3. **Deploy & Verify (30 min)**:
     - `kubectl apply -f crm-deployment.yaml`.
     - `kubectl get pods -n dev-us`: Check Pod status.
     - `kubectl get svc -n dev-us`: Get LoadBalancer URL.
- **Tools**: `kubectl`, AWS Console for EKS.
- **Outcome**: CRM microservices running on EKS, accessible externally.

---

### Assessment
- **Quiz (15 min)**:
  - Define a Pod vs. Deployment.
  - What’s the role of a Service?
  - Explain `kubectl apply`.
- **Hands-On**: 
  - Show running Pods: `kubectl get pods -n dev-us`.
  - Access `crm-ui` via LoadBalancer URL.

---

### Real-World Alignment
- **Salesforce**: Uses K8s for CRM microservices, mirroring our EKS setup.
- **Netflix**: Scales streaming with Deployments and Services, like our CRM.
- **Your Context**: Prepares for Day 4’s advanced K8s and capstone integration.

---

### Next Steps
- **Day 4**: Advanced K8s (Ingress, HPA) for CRM scaling.
- **Capstone**: Multi-region CRM with Terraform + K8s.
